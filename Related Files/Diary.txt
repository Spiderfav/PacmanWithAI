Week 1:

- During this week, I spent most of the time just researching all the techologies I needed to use for my project. These included the algorithms I am going to use as well as the technology needed to complete this project. 
- I have settled on using Golang as my main programming language as it is fast and efficient but, I still have Python in mind if anything goes wrong.
- I have made a list of all the things I need to research:
    - Pathfinding algorithms such as: Dijkstras, A*, Greedy 
    - How to implement Q learning algorithms for the final product
    - How to get a visual, game like interface in Golang to display the maze (using ebitten)


Week 2:

- In this week I had a go at making small programs in golang to get to grips on how to approach this language. 
    - As it is not exactly an object oriented language, trying to implement some ideas in an object oriented way is proving to be more difficult than expected.
- I have also discovered that there are many implementations of maze generating algorithms in golang to be used as packages as well as Pathfinding algorithms
    - This means I can maybe use their implementations and compare them to mine to check how efficient each is when running on the mazes created


Week 3:

- This week, I have begun working on the project and creating the maze graphically. The plan is to at least have a maze by the end of the week.
    - Proving to be more of a challenge than expected as the "ebitten" package that I'm using contains little to no documentation on how to properly use it
    - I am having to figure out how to draw each square on the screen and have it in a way that each square knows its neighbours (so that an algorithm like DFS can be applied to it and a maze created)
    - I have now created the grid for the maze, next part is figuring out how to create a maze from it using DFS


Week 4:

- This week I wanted to already have started on implementing Pathfinding algorithms. However, I had to re-write my implementation for mostly everything so that maze generation algorithms could work.
- However, this week I have:
    - Created the maze generation algorithm (Randomised DFS)
    - Implemented the maze generation algorithm (Randomised DFS) on a given maze grid
    - Created function to generate the maze from a given grid
    - After generation the maze is now stored so that at a later date, the contents can be emptied to a file and reloaded as needed for testing the same maze
        - I have also attached a photo of one of the generations of the maze


Week 5:

- This week, I implemented the Dijkstras algorithm on the mazes.
- Every time the algorithm is run, a shortest path is produced from the start square to the given square.
    - Note: While testing, two opposite corners have been given to calculate the biggest distance.


- TO DO THIS WEEK: Draw the path taken from the start node to the end node?

Week 6:

- I have implemented a drawing function with lines for Dijkstras. It works for the most part but when backtracking, produces some interesting things.
- I remodeled the same drawing function to just simple Dots and number for the user to see the path it took to get to the destination.
- It now also draws to the screen the Start and End node and the distance to get there.
- I created a function that calculates the euclidean distance between two points
- A crude method of A* was also implemented, however it crashes sometimes for an unknown reason.
- Both drawing methods are now both called, each with different colours to see the effects of running each algorithm, i.e which has shortest path.

Week 7:

- Changed the current implementation of the A* algorithm 
    . In the the implementation in week 6, I wasn't storing the values of the nodes and distances correctly and so they ended up being overwritten
    . The revised version for some reason is performing as well as Dijkstras

- Updated the A* function once again to have the correct comparison and the implementation of it now works as expected.